[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Kevin’s Coding Resources",
    "section": "",
    "text": "Welcome!\nThis is a repository of coding resources for myself (and anyone else who wants to use it). Since I am a political economist, most of these resources focus around tasks regarding econometrics, statistics, and (some) data science.\nThe languages I include on here include R, python, and julia. This is being continuously updated - it is basically my code reference for stuff I am using right now.\nFor R code relating to difference-in-differences or causal panel analysis, see this repository.",
    "crumbs": [
      "Welcome!"
    ]
  },
  {
    "objectID": "syntax.html",
    "href": "syntax.html",
    "title": "basic syntax",
    "section": "",
    "text": "assignment and operations, if statements, for loops, functions\n\nThis page contains basics of coding syntax, such as if-statements, for loops, and functions. Use the sidebar to navigate between different sections. No packages are required for this page.\n\n\noperations\nOperations allow us to manipulate objects and their values. Operations include assigning values to objects, and performing calculations on objects.\n\nRPythonJulia\n\n\nIn R, we assign objects a value using an assignment operator of = or &lt;- (both work). For example, we can assign the object x to be equal to a value of 3:\n\n# both do the same thing\nx &lt;- 3\nx = 3\nprint(x)\n\n#&gt; [1] 3\n\n\nWe can use operations to modify these objects.\n\nx + 1   # addition\nx - 1   # subtraction\nx * 2   # multiplication\nx / 2   # division\nx %% 2  # modulo (remainder after division)\n\n\n\n\n\n\n\n\n\n\n\n\n\nvectors\nWe can assign multiple values to an object using vectors. Vectors are the building block of most data analysis.\n\nRPythonJulia\n\n\nWe can assign multiple values to an object by using the c() concatenate function:\n\nx = c(1,3,5)                             # vector of length 3\ny = c(4:10)                              # creates vector of 4,5,6,7,...10\nz = c(\"Australia\", \"Belgium\", \"France\")  # char string vector\n\nprint(x)\nprint(y)\nprint(z)\n\n#&gt; [1] 1 3 5\n#&gt; [1]  4  5  6  7  8  9 10\n#&gt; [1] \"Australia\" \"Belgium\"   \"France\"\n\n\nEach element of a vector has a position. We can extract one element of the vector using indexing with brackets []:\n\nx[3]  # 3rd element of x\n\n#&gt; [1] 5\n\n\nAll elements within a vector must be of the same type.\n\n\n\n\n\n\n\n\n\n\n\n\nif statements\nIf-statements are core to programming. We ask the if-statement to evaluate a statement/condition. If that statement/condition is true, then we ask the code to do something. If it is not true, we ask the code to do something else.\n\nRPythonJulia\n\n\nWe can write an if statement. We can optionally have even more options with else{} and else if{} statements.\n\nx = \"hello\"\n\nif (x == 8) {\n  print(\"yay\")\n} else if (x == \"hello\") {\n  print(\"the second loop is true\")\n} else {\n  print(\"the statement is not true\")\n}\n\n#&gt; [1] \"the second loop is true\"\n\n\nR also has an ifelse() function, which is vectorised, and can be useful within data manipulation of variable vectors.\n\nx = ifelse(\n  test  = x == \"hello\",  # condition\n  yes   = 8,             # what to do if condition is true\n  no    = 0              # what to do if condition is false\n)\nprint(x)\n\n#&gt; [1] 8\n\n\nThe conditions/statements within the if{} can have the following comparisons:\n\n==  # equal\n!=  # not equal\n&gt;   # greater than\n&gt;=  # greater than or equal\n&lt;   # less than\n&lt;=  # less than or equal\n\n\n\n\n\n\n\n\n\n\n\n\n\nfor loops\nfor loops allow us to repeat the same code multiple times for different inputs. It can be much more efficient than copy-pasting the same code over and over again for different inputs.\n\nRPythonJulia\n\n\nFirst, we define the inputs we want to use in our loop by storing them in an object. Then, we tell R to run the loop for every input within our object.\n\nnum = c(1,3,5)  # inputs for the for loop\n\nfor (i in num) {\n  print(i*2)\n}\n\n#&gt; [1] 2\n#&gt; [1] 6\n#&gt; [1] 10\n\n\nWe can see above, that we asked R to run print(i*2) for every element i within object num.\n\n\n\n\n\n\n\n\n\n\n\n\nfunctions\nLet us say you have some chunk of code you are using over and over again in your project. Instead of rewriting it every time you want to use it, you can instead create a function.\n\nRPythonJulia\n\n\nLet us say I will frequently be needing to multiply two numbers (very simple example). Lets define a function my.func() that does this.\n\nmy.func = function(num1, num2) {\n  print(num1 * num2)\n}\n\nThis function has two arguments - num1 and num2, that when calling the function, I will need to provide:\n\nmy.func(num1 = 3, num2 = 4)\n\n#&gt; [1] 12\n\n\nObviously this function is very simple, but if you are repeating a task that takes many lines of code, doing this will allow you to avoid copy-pasting long lines of code every time.",
    "crumbs": [
      "basic syntax"
    ]
  },
  {
    "objectID": "import.html",
    "href": "import.html",
    "title": "manage data",
    "section": "",
    "text": "importing data, viewing data, creating data, writing data\n\nThis page covers how to import, view, and export data, and basics of dataframes. Use the sidebar to navigate between different sections.\n\nRPythonJulia\n\n\nFor the R code on this page, we will need the readr package, and potentially the haven package if you are dealing with stata .dta, SAS, or SPSS files.\n\n# packages needed:\nlibrary(readr)\nlibrary(haven)  # only needed if dealing with stata or sas files\n\nreadr is part of the tidyverse package, so you can choose to load tidyverse instead.\n\n\n\n\n\n\n\n\n\n\n\nimporting data\nWe can import data from a variety of different file types.\n\nRPythonJulia\n\n\nBefore we import data, we need to tell our software where our data is stored by setting a directory. We can set the working directory with the setwd() function.\n\nsetwd(\"/Users/folder1/folder2\")  # put path to folder in quotes\n\nYou can get the path to any file on your computer as follows:\n\nMac: open finder, go to your folder. Then click view on the top bar, select “show path bar”. A path bar should appear on the bottom of your finder window. Then control + click (or right click) your folder in the path bar, and click ’copy “foldername” as path name”.\nWindows: right click your folder, click “copy as path”.\n\nLoad .csv files (comma seperated format, excel) into object df:\n\ndf = read_csv('data.csv')\n\nLoad .dta files (stata format) into object df:\n\n# library(haven)\ndf = read_dta('data.dta')\n\n\n\n\n\n\n\n\n\n\n\n\n\ncreating dataframes\nWe don’t have to import data. We can also manually create data with vectors and matrices.\n\nRPythonJulia\n\n\nWe start off by creating vectors, each vector being a variable.\n\nperson = c(1:5)\nage = c(10,20,13,14,12)\nname = c(\"bob\", \"ana\", \"mia\", \"pop\", \"ben\")\n\nWe then use the data.frame() function to join these vectors into a dataframe:\n\ndf = data.frame(person, age, name)\n\nprint(df)\n\n#&gt;   person age name\n#&gt; 1      1  10  bob\n#&gt; 2      2  20  ana\n#&gt; 3      3  13  mia\n#&gt; 4      4  14  pop\n#&gt; 5      5  12  ben\n\n\nWe now have a dataframe.\n\n\n\n\n\n\n\n\n\n\n\n\npreview data\nGetting a brief overview of our data before we change/filter/select it.\n\nRPythonJulia\n\n\nUsing function head() to see the first few rows of the dataframe df:\n\nhead(df)\n\n#&gt;   person age name\n#&gt; 1      1  10  bob\n#&gt; 2      2  20  ana\n#&gt; 3      3  13  mia\n#&gt; 4      4  14  pop\n#&gt; 5      5  12  ben\n\n\nUsing function summary() to see a summary of columns (variables) of df:\n\nsummary(df)\n\n#&gt;      person       age           name          \n#&gt;  Min.   :1   Min.   :10.0   Length:5          \n#&gt;  1st Qu.:2   1st Qu.:12.0   Class :character  \n#&gt;  Median :3   Median :13.0   Mode  :character  \n#&gt;  Mean   :3   Mean   :13.8                     \n#&gt;  3rd Qu.:4   3rd Qu.:14.0                     \n#&gt;  Max.   :5   Max.   :20.0\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nindexing\nIndexing allows us to select certain variables and elements within a dataframe, which allows us to perform operations on them.\n\nRPythonJulia\n\n\nWe can index for a specific variable (column) by using the syntax df$variable:\n\nprint(df$age)\n\n#&gt; [1] 10 20 13 14 12\n\n\nAs df$variable is a vector, we can index like we did previously.\nWe can also index elements by row and column number. The syntax is given by df[row, col]. For example:\n\ndf[2,]   # extract 2nd row\n\n#&gt;   person age name\n#&gt; 2      2  20  ana\n\ndf[,2]   # extract 2nd column\n\n#&gt; [1] 10 20 13 14 12\n\ndf[2,2]  # exrtract the element at row = 2 and col = 2\n\n#&gt; [1] 20\n\n\nWe will discuss subsetting the data (extracting more than 1 row and 1 column) in data wrangling.\n\n\n\n\n\n\n\n\n\n\n\n\nexport data\nOnce we complete data manipulation, we can export our data\n\nRPythonJulia\n\n\nWe can export our data frame df to a .csv file using write_csv():\n\ndf |&gt; write_csv(\"filename.csv\")  # export data to file called filename.csv\n\nWe can export our data frame df to a .dta (stata) file using write_dta():\n\nlibrary(haven)\ndf |&gt; write_dta(\"filename.dta\")  # export data to file called filename.dta\n\nWe can export our data to a .sas7bdat (SAS) file using write_sas():\n\nlibrary(haven)\ndf |&gt; write_sas(\"filename.sas7bdat\")  # export data to file called filename.sas7bdat\n\nWe can export our data to a .sav (SPSS) file using write_sav():\n\nlibrary(haven)\ndf |&gt; write_sav(\"filename.sav\")  # export data to file called filename.sav",
    "crumbs": [
      "manage data"
    ]
  },
  {
    "objectID": "data.html",
    "href": "data.html",
    "title": "data wrangling",
    "section": "",
    "text": "filtering and sorting, dealing with missing data, manipulating data\n\nThis page covers how to manipulate data. For importing data and basics of dataframes, see here. For data summary, see here. Use the sidebar to navigate between different sections.\n\nRPythonJulia\n\n\nFor the R code on this page, we will need the dplyr package.\n\n# packages needed:\nlibrary(dplyr)\n\ndplyr is part of the tidyverse package, so you can choose to load tidyverse instead.\n\n\n\n\n\n\n\n\n\n\n\nsubsetting data\nSubsetting variables involves choosing only a subset of the variables from the original dataframe. For example, you have 10 variables, but you only need 4 for analysis.\n\nRPythonJulia\n\n\nTo subset our data by only including some variables, use the select() function:\n\nnew.df = df |&gt;\n  select(gini, export, voc)  # select variables \"gini\", \"export\", \"voc\"\n\nnew.df |&gt; head()             # display first few obs\n\n#&gt; # A tibble: 6 × 3\n#&gt;    gini export   voc\n#&gt;   &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1  33.1   18.2     0\n#&gt; 2  33.1   19.9     0\n#&gt; 3  33.1   20.2     0\n#&gt; 4  33.1   20.1     0\n#&gt; 5  35.4   23.0     0\n#&gt; 6  35.4   19.8     0\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfiltering observations\nFiltering observations involves only keeping certain observations with certain values. For example, only keeping observations from the country of Canada.\n\nRPythonJulia\n\n\nWe can filter for only observations that meet certain conditions with the filter() function. We input the condition within the filter() function to create a new dataframe new.df from our original df:\n\nnew.df = df |&gt;\n  filter(countryname == \"australia\" | countryname == \"belgium\")  # keep obs from australia or belgium\n\nnew.df |&gt; head()                                                 # display first few obs\n\n#&gt; # A tibble: 6 × 13\n#&gt;      id countryid countryname countrycode  year   voc taxpercent corporatetax\n#&gt;   &lt;dbl&gt;     &lt;dbl&gt; &lt;chr&gt;       &lt;chr&gt;       &lt;dbl&gt; &lt;dbl&gt;      &lt;dbl&gt;        &lt;dbl&gt;\n#&gt; 1     1         1 australia   aus          2004     0       30.1           30\n#&gt; 2     2         1 australia   aus          2005     0       29.8           30\n#&gt; 3     3         1 australia   aus          2006     0       29.3           30\n#&gt; 4     4         1 australia   aus          2007     0       29.4           30\n#&gt; 5     5         1 australia   aus          2008     0       26.7           30\n#&gt; 6     6         1 australia   aus          2009     0       25.4           30\n#&gt; # ℹ 5 more variables: personaltax &lt;dbl&gt;, econglobal &lt;dbl&gt;, gini &lt;dbl&gt;,\n#&gt; #   socialexp &lt;dbl&gt;, export &lt;dbl&gt;\n\n\nWe can have one condition, or multiple conditions. For multiple conditions, we should connect them with AND or OR operators:\n\ncountryname == \"australia\" | countryname == \"belgium\"  # OR operator |\ncountryname == \"australia\" & voc == 1                   # AND operator &\n\nThe comparison operators in R are as follows:\n\n==  # equal\n!=  # not equal\n&gt;   # greater than\n&gt;=  # greater than or equal\n&lt;   # less than\n&lt;=  # less than or equal\n\n\n\n\n\n\n\n\n\n\n\n\n\nadding variables\nWe can add variables to our data frames.\n\nRPythonJulia\n\n\nWe can create a new variable newvar with the mutate() function: You can assign any “rule” to create the new variable.\n\nWe can use any operator like addition, subtraction, division, etc.\nWe can also assign values based on ifelse() statements and other rules (see basic syntax).\n\nFor example, we can assign newvar to equal 10 if voc == 1, and 20 otherwise:\n\ndf = df |&gt;\n  mutate(newvar = ifelse(voc == 1, 10, 20))\n\ndf$newvar |&gt; head()           # we can see values of newvar here now\n\n#&gt; [1] 20 20 20 20 20 20\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nmissing values\nMissing values are often present in data. These can cause issues with estimation and models, so we need some way of identifying and getting rid of them.\n\nRPythonJulia\n\n\nMissing values are coded as NA or NaN in dataframes.\nTo detect missing values, we can use the is.na() function. This function detects if there is a missing value in each position of a dataframe or vector, and outputs a TRUE or FALSE, with TRUE indicating a missing value.\n\nis.na(df$voc) |&gt; head()  # head() to avoid long output, you do not need head()\n\n#&gt; [1] FALSE FALSE FALSE FALSE FALSE FALSE\n\n\nWe can replace any NAs with an if-else statement. For example, we might want to replace any NA in variable voc with the value 0:\n\ndf$voc &lt;- ifelse(\n  test  = is.na(df$voc) == TRUE,  # check if obs is a NA\n  yes   = 0,                      # if it is NA, replace with 0\n  no    = df$voc                  # if not NA, keep original voc value\n)\n\nWe can also omit any observations with NA values from the dataframe or vector of interest with the na.omit() function:\n\ndf = na.omit(df)  # omit any observation with NA value\n\n\n\n\n\n\n\n\n\n\n\n\n\nvariable types\nIt is important to ensure our variables are of the correct type, to ensure our analysis works as intended.\n\nRPythonJulia\n\n\nR variables can be of many different “types”, which operate differently in analysis.\nNumeric variables are any number, including decimals and negatives. We can coerce any variable into a numeric type with the as.numeric() function:\n\n# convert variable voc into numeric type\ndf$voc = as.numeric(df$voc)\n\nInteger variables are variables that only take values of integers, i.e. whole numbers. We can coerce any variable into an integer type with the as.integer() function:\n\n# convert variable voc into integer type\ndf$voc = as.integer(df$voc)\n\nFactor variables are variables that will be treated as categorical/binary variables in statistical analysis (ex. male/female, yes/no, country). We can coerce any variable into a factor type with the as.factor() function:\n\n# convert variable voc into factor type\ndf$voc = as.factor(df$voc)\n\nCharacter strings are variables that contain letters and symbols. We rarely wish to change other types into characters, but it is possible to coerce any variable into a character type with the as.character() function:\n\n# convert variable voc into factor type\ndf$voc = as.character(df$voc)\n\n\n\n\n\n\n\n\n\n\n\n\n\nmerging data\nWe can merge dataframes together to form bigger dataframes for anlaysis. We can either merge together two dataframes with the same observations but different variables (column binding), or merge together two dataframes with the same variables but different observations (joining).\n\nRPythonJulia\n\n\nTo merge two dataframes with different variables but the same observations (so merging columns), we can use the cbind() function. For example, here we have two dataframes, each with 3 variables, including id that indicates each observation. We can merge them together to form a new dataframe:\n\nhead(df1, 1)               # look at df1\n\n#&gt; # A tibble: 1 × 3\n#&gt;      id   voc  gini\n#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1     1     0  33.1\n\nhead(df2, 1)               # look at df2\n\n#&gt; # A tibble: 1 × 3\n#&gt;      id export socialexp\n#&gt;   &lt;dbl&gt;  &lt;dbl&gt;     &lt;dbl&gt;\n#&gt; 1     1   18.2      17.2\n\nnew.df = cbind(df1, df2)  # combine df1 and df2\n\nhead(new.df)              # see that df1 and df2 have combined\n\n#&gt;   id voc gini id export socialexp\n#&gt; 1  1   0 33.1  1 18.224    17.197\n#&gt; 2  2   0 33.1  2 19.854    16.660\n#&gt; 3  3   0 33.1  3 20.184    15.699\n#&gt; 4  4   0 33.1  4 20.149    15.858\n#&gt; 5  5   0 35.4  5 23.011    17.050\n#&gt; 6  6   0 35.4  6 19.795    16.853\n\n\nThe joining will be based on the shared variable between the two dataframes. This is usually an observation id.\nTo merge two dataframes with the same variables but different observations (essentially joining more observations together), we can use the full_join() function:\n\n# df1 has australia obs, df2 has belgium obs\nnew.df = full_join(df1, df2)\n\nThe joining will be done by the shared variables (columns).",
    "crumbs": [
      "data wrangling"
    ]
  },
  {
    "objectID": "stats.html",
    "href": "stats.html",
    "title": "summary stats",
    "section": "",
    "text": "stats by variable\n\n\nsummary stats table\n\n\nstats by group\n\n\nlength and unique\n\n\ncorrelations",
    "crumbs": [
      "summary stats"
    ]
  },
  {
    "objectID": "plot.html",
    "href": "plot.html",
    "title": "plotting",
    "section": "",
    "text": "box and whisker\n\n\nbar plots\n\n\nscatterplots\n\n\nestimate plots\nwith confidence intervals\n\n\ngrid plots\ngrids of multiple plots\n\n\nadding lines\n\n\nlabel graphs\n\n\nlegends\n\n\nthemes",
    "crumbs": [
      "plotting"
    ]
  },
  {
    "objectID": "reg.html",
    "href": "reg.html",
    "title": "linear models",
    "section": "",
    "text": "linear model\n\n\nlogistic\n\n\npoisson\n\n\nnegative binomial\n\n\nspecification",
    "crumbs": [
      "linear models"
    ]
  },
  {
    "objectID": "ds.html",
    "href": "ds.html",
    "title": "data science",
    "section": "",
    "text": "random forest\n\n\npca\n\n\nfactor anlaysis\n\n\nk-means cluster",
    "crumbs": [
      "data science"
    ]
  },
  {
    "objectID": "metrics.html",
    "href": "metrics.html",
    "title": "econometrics",
    "section": "",
    "text": "iv estimator\n\n\nreg discontinuity\n\n\ndid twfe\n\n\ndid event study\n\n\ncsdid",
    "crumbs": [
      "econometrics"
    ]
  }
]