[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Kevin’s Coding Resources",
    "section": "",
    "text": "Welcome!\nThis is a repository of coding resources for myself (and anyone else who wants to use it). Since I am a political economist, most of these resources focus around tasks regarding econometrics, statistics, and (some) data science.\nThe languages I include on here include R, python, and julia. This is being continuously updated - it is basically my code reference for stuff I am using right now.\nFor R code relating to difference-in-differences or causal panel analysis, see this repository.",
    "crumbs": [
      "Welcome!"
    ]
  },
  {
    "objectID": "objects.html",
    "href": "objects.html",
    "title": "objects",
    "section": "",
    "text": "vectors, dataframes, indexing\n\nThis page introduces the basics of objects, including vectors, dataframes, and indexing, from a statistics/data perspective. The packages required for this page are:\n\nRPythonJulia\n\n\nNo packages are required for R.\n\n\n\n\n\n\n\n\n\n\n\nvectors\nWe can assign multiple values to an object using vectors. Vectors are the building block of most data analysis.\n\nRPythonJulia\n\n\nWe can assign multiple values to an object by using the c() concatenate function:\n\nx = c(1,3,5)                             # vector of length 3\ny = c(4:10)                              # creates vector of 4,5,6,7,...10\nz = c(\"Australia\", \"Belgium\", \"France\")  # char string vector\n\nprint(x)\nprint(y)\nprint(z)\n\n#&gt; [1] 1 3 5\n#&gt; [1]  4  5  6  7  8  9 10\n#&gt; [1] \"Australia\" \"Belgium\"   \"France\"\n\n\nEach element of a vector has a position. We can extract one element of the vector using indexing with brackets []:\n\nx[3]  # 3rd element of x\n\n#&gt; [1] 5\n\n\nAll elements within a vector must be of the same type.\n\n\n\n\n\n\n\n\n\n\n\n\ndataframes\nDataframes are a combination of multiple column vectors, where each vector represents a variable in the data.\n\nRPythonJulia\n\n\nWe start off by creating vectors, each vector being a variable.\n\nperson = c(1:5)\nage = c(10,20,13,14,12)\nname = c(\"bob\", \"ana\", \"mia\", \"pop\", \"ben\")\n\nWe then use the data.frame() function to join these vectors into a dataframe:\n\ndf = data.frame(person, age, name)\n\nprint(df)\n\n#&gt;   person age name\n#&gt; 1      1  10  bob\n#&gt; 2      2  20  ana\n#&gt; 3      3  13  mia\n#&gt; 4      4  14  pop\n#&gt; 5      5  12  ben\n\n\nWe now have a dataframe.\n\n\n\n\n\n\n\n\n\n\n\n\nindexing\nIndexing allows us to select certain variables and elements within a dataframe, which allows us to perform operations on them.\n\nRPythonJulia\n\n\nWe can index for a specific variable (column) by using the syntax df$variable:\n\nprint(df$age)\n\n#&gt; [1] 10 20 13 14 12\n\n\nAs df$variable is a vector, we can index like we did previously.\nWe can also index elements by row and column number. The syntax is given by df[row, col]. For example:\n\ndf[2,]   # extract 2nd row\n\n#&gt;   person age name\n#&gt; 2      2  20  ana\n\ndf[,2]   # extract 2nd column\n\n#&gt; [1] 10 20 13 14 12\n\ndf[2,2]  # exrtract the element at row = 2 and col = 2\n\n#&gt; [1] 20\n\n\nWe will discuss subsetting the data (extracting more than 1 row and 1 column) in data wrangling.",
    "crumbs": [
      "objects"
    ]
  },
  {
    "objectID": "syntax.html",
    "href": "syntax.html",
    "title": "syntax",
    "section": "",
    "text": "if statements, for loops, functions\n\nThis page contains basics of coding syntax, such as if-statements, for loops, and functions. No packages are required for this page.\n\n\nif statements\nIf-statements are core to programming. We ask the if-statement to evaluate a statement/condition. If that statement/condition is true, then we ask the code to do something. If it is not true, we ask the code to do something else.\n\nRPythonJulia\n\n\nWe can write an if statement. We can optionally have even more options with else{} and else if{} statements.\n\nx = \"hello\"\n\nif (x == 8) {\n  print(\"yay\")\n} else if (x == \"hello\") {\n  print(\"the second loop is true\")\n} else {\n  print(\"the statement is not true\")\n}\n\n#&gt; [1] \"the second loop is true\"\n\n\nR also has an ifelse() function, which is vectorised, and can be useful within data manipulation of variable vectors.\n\nx = ifelse(\n  test  = x == \"hello\",  # condition\n  yes   = 8,             # what to do if condition is true\n  no    = 0              # what to do if condition is false\n)\nprint(x)\n\n#&gt; [1] 8\n\n\nThe conditions/statements within the if{} can have the following comparisons:\n\n==  # equal\n!=  # not equal\n&gt;   # greater than\n&gt;=  # greater than or equal\n&lt;   # less than\n&lt;=  # less than or equal\n\n\n\n\n\n\n\n\n\n\n\n\n\nfor loops\nfor loops allow us to repeat the same code multiple times for different inputs. It can be much more efficient than copy-pasting the same code over and over again for different inputs.\n\nRPythonJulia\n\n\nFirst, we define the inputs we want to use in our loop by storing them in an object. Then, we tell R to run the loop for every input within our object.\n\nnum = c(1,3,5)  # inputs for the for loop\n\nfor (i in num) {\n  print(i*2)\n}\n\n#&gt; [1] 2\n#&gt; [1] 6\n#&gt; [1] 10\n\n\nWe can see above, that we asked R to run print(i*2) for every element i within object num.\n\n\n\n\n\n\n\n\n\n\n\n\nfunctions\nLet us say you have some chunk of code you are using over and over again in your project. Instead of rewriting it every time you want to use it, you can instead create a function.\n\nRPythonJulia\n\n\nLet us say I will frequently be needing to multiply two numbers (very simple example). Lets define a function my.func() that does this.\n\nmy.func = function(num1, num2) {\n  print(num1 * num2)\n}\n\nThis function has two arguments - num1 and num2, that when calling the function, I will need to provide:\n\nmy.func(num1 = 3, num2 = 4)\n\n#&gt; [1] 12\n\n\nObviously this function is very simple, but if you are repeating a task that takes many lines of code, doing this will allow you to avoid copy-pasting long lines of code every time.",
    "crumbs": [
      "syntax"
    ]
  },
  {
    "objectID": "import.html",
    "href": "import.html",
    "title": "manage data",
    "section": "",
    "text": "importing data, viewing data, creating data, writing data\n\nThis page covers how to import, view, and export data. Use the sidebar to navigate between different sections. The following packages are needed:\n\nRPythonJulia\n\n\nWe will need the tidyverse package, and potentially the haven package if you are dealing with stata .dta, SAS, or SPSS files.\n\n# packages needed:\nlibrary(tidyverse)\nlibrary(haven)  # only needed if dealing with stata or sas files\n\n\n\nWe will need the pandas package (and os package for working directory).\n\n# packages needed:\nimport os\nimport pandas as pd\n\n\n\n\n\n\n\n\n\nimporting data\nMost often, we will have external data that we need to import in order to conduct anlaysis on.\n\nRPythonJulia\n\n\nBefore we import data, we need to tell our software where our data is stored by setting a directory. We can set the working directory with the setwd() function.\n\nsetwd(\"/Users/folder1/folder2\")  # put path to folder in quotes\n\nYou can get the path to any file on your computer as follows:\n\nMac: open finder, go to your folder. Then click view on the top bar, select “show path bar”. A path bar should appear on the bottom of your finder window. Then control + click (or right click) your folder in the path bar, and click ’copy “foldername” as path name”.\nWindows: right click your folder, click “copy as path”.\n\nLoad .csv files (comma seperated format, excel) into object df:\n\ndf = read_csv('data.csv')\n\nLoad .dta files (stata format) into object df:\n\n# library(haven)\ndf = read_dta('data.dta')\n\n\n\nBefore we import data, we need to tell our software where our data is stored by setting a directory. We can set the working directory with the setwd() function.\n\nos.chdir('[/Users/folder1/folder2]')  # put path to folder\n\nYou can get the path to any file on your computer as follows:\n\nMac: open finder, go to your folder. Then click view on the top bar, select “show path bar”. A path bar should appear on the bottom of your finder window. Then control + click (or right click) your folder in the path bar, and click ’copy “foldername” as path name”.\nWindows: right click your folder, click “copy as path”.\n\nLoad .csv files (comma seperated format, excel) into object df:\n\ndf = pd.read_csv('data.csv')\n\nLoad .dta files (stata format) into object df:\n\ndf = pd.read_stata('data.dta')\n\n\n\n\n\n\n\n\n\n\npreview data\nBefore starting any data manipulation or analysis, it is useful to understand the structure of our data. We can do this by previewing the data.\n\nRPythonJulia\n\n\nUsing function head() to see the first few rows of the dataframe df:\n\nhead(df)\n\n#&gt; # A tibble: 6 × 13\n#&gt;      id countryid countryname countrycode  year   voc taxpercent corporatetax\n#&gt;   &lt;dbl&gt;     &lt;dbl&gt; &lt;chr&gt;       &lt;chr&gt;       &lt;dbl&gt; &lt;dbl&gt;      &lt;dbl&gt;        &lt;dbl&gt;\n#&gt; 1     1         1 australia   aus          2004     0       30.1           30\n#&gt; 2     2         1 australia   aus          2005     0       29.8           30\n#&gt; 3     3         1 australia   aus          2006     0       29.3           30\n#&gt; 4     4         1 australia   aus          2007     0       29.4           30\n#&gt; 5     5         1 australia   aus          2008     0       26.7           30\n#&gt; 6     6         1 australia   aus          2009     0       25.4           30\n#&gt; # ℹ 5 more variables: personaltax &lt;dbl&gt;, econglobal &lt;dbl&gt;, gini &lt;dbl&gt;,\n#&gt; #   socialexp &lt;dbl&gt;, export &lt;dbl&gt;\n\n\nUsing function glimpse() to see a summary of columns (variables) of df:\n\nglimpse(df)\n\n#&gt; Rows: 255\n#&gt; Columns: 13\n#&gt; $ id           &lt;dbl&gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17…\n#&gt; $ countryid    &lt;dbl&gt; 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, …\n#&gt; $ countryname  &lt;chr&gt; \"australia\", \"australia\", \"australia\", \"australia\", \"aust…\n#&gt; $ countrycode  &lt;chr&gt; \"aus\", \"aus\", \"aus\", \"aus\", \"aus\", \"aus\", \"aus\", \"aus\", \"…\n#&gt; $ year         &lt;dbl&gt; 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 201…\n#&gt; $ voc          &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, …\n#&gt; $ taxpercent   &lt;dbl&gt; 30.145, 29.849, 29.301, 29.423, 26.743, 25.425, 25.160, 2…\n#&gt; $ corporatetax &lt;dbl&gt; 30.00, 30.00, 30.00, 30.00, 30.00, 30.00, 30.00, 30.00, 3…\n#&gt; $ personaltax  &lt;dbl&gt; 31.50, 31.50, 31.50, 31.50, 31.50, 31.50, 31.50, 31.50, 3…\n#&gt; $ econglobal   &lt;dbl&gt; 66.901, 66.871, 68.431, 69.648, 66.550, 67.422, 67.356, 6…\n#&gt; $ gini         &lt;dbl&gt; 33.1, 33.1, 33.1, 33.1, 35.4, 35.4, 34.7, 34.7, 34.7, 34.…\n#&gt; $ socialexp    &lt;dbl&gt; 17.197, 16.660, 15.699, 15.858, 17.050, 16.853, 16.553, 1…\n#&gt; $ export       &lt;dbl&gt; 18.224, 19.854, 20.184, 20.149, 23.011, 19.795, 21.436, 2…\n\n\n\n\nUsing function .head() to see the first few rows of the dataframe df:\n\ndf.head()\n\n#&gt;    id  countryid countryname countrycode  ...  econglobal  gini  socialexp  export\n#&gt; 0   1          1   australia         aus  ...      66.901  33.1     17.197  18.224\n#&gt; 1   2          1   australia         aus  ...      66.871  33.1     16.660  19.854\n#&gt; 2   3          1   australia         aus  ...      68.431  33.1     15.699  20.184\n#&gt; 3   4          1   australia         aus  ...      69.648  33.1     15.858  20.149\n#&gt; 4   5          1   australia         aus  ...      66.550  35.4     17.050  23.011\n#&gt; \n#&gt; [5 rows x 13 columns]\n\n\nUsing function .info() to see a summary of columns (variables) of df:\n\ndf.info()\n\n#&gt; &lt;class 'pandas.core.frame.DataFrame'&gt;\n#&gt; RangeIndex: 255 entries, 0 to 254\n#&gt; Data columns (total 13 columns):\n#&gt;  #   Column        Non-Null Count  Dtype  \n#&gt; ---  ------        --------------  -----  \n#&gt;  0   id            255 non-null    int64  \n#&gt;  1   countryid     255 non-null    int64  \n#&gt;  2   countryname   255 non-null    object \n#&gt;  3   countrycode   255 non-null    object \n#&gt;  4   year          255 non-null    int64  \n#&gt;  5   voc           255 non-null    int64  \n#&gt;  6   taxpercent    255 non-null    float64\n#&gt;  7   corporatetax  255 non-null    float64\n#&gt;  8   personaltax   255 non-null    float64\n#&gt;  9   econglobal    255 non-null    float64\n#&gt;  10  gini          255 non-null    float64\n#&gt;  11  socialexp     255 non-null    float64\n#&gt;  12  export        255 non-null    float64\n#&gt; dtypes: float64(7), int64(4), object(2)\n#&gt; memory usage: 26.0+ KB\n\n\n\n\n\n\n\n\n\n\n\nexport data\nOnce we complete data manipulation, we can export our data to our computer.\n\nRPythonJulia\n\n\nWe can export our data frame df to a .csv file using write_csv():\n\ndf |&gt; write_csv(\"filename.csv\")  # export data to file called filename.csv\n\nWe can export our data frame df to a .dta (stata) file using write_dta():\n\nlibrary(haven)\ndf |&gt; write_dta(\"filename.dta\")  # export data to file called filename.dta\n\n\n\nWe can export our data frame df to a .csv file using .to_csv():\n\ndf.to_csv('filename.csv') # export data to file called filename.csv\n\nWe can export our data frame df to a .dta (stata) file using write_dta():\n\ndf.to_stata('filename.dta') # export data to file called filename.dta",
    "crumbs": [
      "manage data"
    ]
  },
  {
    "objectID": "subset.html",
    "href": "subset.html",
    "title": "subset data",
    "section": "",
    "text": "subseting data, filtering data\n\nThis page covers how to subset data. Use the sidebar to navigate between different sections. The packages required are:\n\nRPythonJulia\n\n\nFor the R code on this page, we will need the dplyr package.\n\n# packages needed:\nlibrary(dplyr)\n\ndplyr is part of the tidyverse package, so you can choose to load tidyverse instead.\n\n\nWe will need the pandas package:\n\n# packages needed:\nimport pandas as pd\n\n\n\n\n\n\n\n\n\nsubsetting data\nSubsetting variables involves choosing only a subset of the variables from the original dataframe. For example, you have 10 variables, but you only need 4 for analysis.\n\nRPythonJulia\n\n\nTo subset our data by only including some variables (columns), use the select() function:\n\nnew.df = df |&gt;\n  select(gini, export, voc)  # select variables \"gini\", \"export\", \"voc\"\n\nnew.df |&gt; head()             # display first few obs\n\n#&gt; # A tibble: 6 × 3\n#&gt;    gini export   voc\n#&gt;   &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1  33.1   18.2     0\n#&gt; 2  33.1   19.9     0\n#&gt; 3  33.1   20.2     0\n#&gt; 4  33.1   20.1     0\n#&gt; 5  35.4   23.0     0\n#&gt; 6  35.4   19.8     0\n\n\n\n\nTo subset our data by including only some variables (columns), we use the following syntax:\n\nnew_df = df[['gini', 'export', 'voc']]  # select variables\nnew_df.head()                           # display first few obs\n\n#&gt;    gini  export  voc\n#&gt; 0  33.1  18.224    0\n#&gt; 1  33.1  19.854    0\n#&gt; 2  33.1  20.184    0\n#&gt; 3  33.1  20.149    0\n#&gt; 4  35.4  23.011    0\n\n\n\n\n\n\n\n\n\n\n\nfiltering observations\nFiltering observations involves only keeping certain observations with certain values. For example, only keeping observations from the country of Canada.\n\nRPythonJulia\n\n\nWe can filter for only observations that meet certain conditions with the filter() function. We input the condition within the filter() function to create a new dataframe new.df from our original df:\n\nnew.df = df |&gt;\n  filter(countryname == \"belgium\" | countryname == \"canada\")   # keep obs from australia or belgium\n\nnew.df |&gt; head()                                                 # display first few obs\n\n#&gt; # A tibble: 6 × 13\n#&gt;      id countryid countryname countrycode  year   voc taxpercent corporatetax\n#&gt;   &lt;dbl&gt;     &lt;dbl&gt; &lt;chr&gt;       &lt;chr&gt;       &lt;dbl&gt; &lt;dbl&gt;      &lt;dbl&gt;        &lt;dbl&gt;\n#&gt; 1    18         2 canada      can          2004     0       32.7         34.4\n#&gt; 2    19         2 canada      can          2005     0       32.7         34.2\n#&gt; 3    20         2 canada      can          2006     0       32.7         33.9\n#&gt; 4    21         2 canada      can          2007     0       32.5         34.0\n#&gt; 5    22         2 canada      can          2008     0       31.2         31.4\n#&gt; 6    23         2 canada      can          2009     0       32.3         30.9\n#&gt; # ℹ 5 more variables: personaltax &lt;dbl&gt;, econglobal &lt;dbl&gt;, gini &lt;dbl&gt;,\n#&gt; #   socialexp &lt;dbl&gt;, export &lt;dbl&gt;\n\n\nWe can have one condition, or multiple conditions. For multiple conditions, we should connect them with AND or OR operators:\n\ncountryname == \"belgium\" | countryname == \"canada\"  # OR operator |\ncountryname == \"australia\" & voc == 1               # AND operator &\n\nThe comparison operators in R are as follows:\n\n==  # equal\n!=  # not equal\n&gt;   # greater than\n&gt;=  # greater than or equal\n&lt;   # less than\n&lt;=  # less than or equal\n\n\n\nWe can filter for only observations that meet certain conditions with the .loc() function. We input the condition within the .loc() function to create a new dataframe new_df from our original df:\n\nnew_df = df.loc[(df['countryname'] == 'belgium') | (df['countryname'] == 'canada')]\nnew_df.head()\n\n#&gt;     id  countryid countryname countrycode  ...  econglobal  gini  socialexp  export\n#&gt; 17  18          2      canada         can  ...      67.796  33.8     16.098  37.328\n#&gt; 18  19          2      canada         can  ...      67.531  33.6     15.953  36.856\n#&gt; 19  20          2      canada         can  ...      67.464  34.1     16.346  35.402\n#&gt; 20  21          2      canada         can  ...      67.875  33.8     16.264  34.230\n#&gt; 21  22          2      canada         can  ...      66.958  33.9     16.352  34.395\n#&gt; \n#&gt; [5 rows x 13 columns]\n\n\nWe can have one condition, or multiple conditions. For multiple conditions, we should connect them with AND or OR operators:\n\n(df['countryname'] == 'belgium') | (df['countryname'] == 'canada')  # OR operator |\n(df['countryname'] == 'belgium') & (df['countryname'] == 'canada')  # AND operator &\n\nThe comparison operators in python are as follows:\n\n==  # equal\n!=  # not equal\n&gt;   # greater than\n&gt;=  # greater than or equal\n&lt;   # less than\n&lt;=  # less than or equal",
    "crumbs": [
      "subset data"
    ]
  },
  {
    "objectID": "data.html",
    "href": "data.html",
    "title": "data wrangling",
    "section": "",
    "text": "adding variables, merging data\n\nThis page covers how to manipulate data. Use the sidebar to navigate between different sections. The packages required are:\n\nRPythonJulia\n\n\nFor the R code on this page, we will need the dplyr package.\n\n# packages needed:\nlibrary(dplyr)\n\ndplyr is part of the tidyverse package, so you can choose to load tidyverse instead.\n\n\n\n\n\n\n\n\n\n\n\nadding variables\nWe can add variables to our data frames.\n\nRPythonJulia\n\n\nWe can create a new variable newvar with the mutate() function: You can assign any “rule” to create the new variable.\n\nWe can use any operator like addition, subtraction, division, etc.\nWe can also assign values based on ifelse() statements and other rules (see basic syntax).\n\nFor example, we can assign newvar to equal 10 if voc == 1, and 20 otherwise:\n\ndf = df |&gt;\n  mutate(newvar = ifelse(voc == 1, 10, 20))\n\ndf$newvar |&gt; head()           # we can see values of newvar here now\n\n#&gt; [1] 20 20 20 20 20 20\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nmerging data\nWe can merge dataframes together to form bigger dataframes for anlaysis. We can either merge together two dataframes with the same observations but different variables (column binding), or merge together two dataframes with the same variables but different observations (joining).\n\nRPythonJulia\n\n\nTo merge two dataframes with different variables but the same observations (so merging columns), we can use the cbind() function. For example, here we have two dataframes, each with 3 variables, including id that indicates each observation. We can merge them together to form a new dataframe:\n\nhead(df1, 1)               # look at df1\n\n#&gt; # A tibble: 1 × 3\n#&gt;      id   voc  gini\n#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1     1     0  33.1\n\nhead(df2, 1)               # look at df2\n\n#&gt; # A tibble: 1 × 3\n#&gt;      id export socialexp\n#&gt;   &lt;dbl&gt;  &lt;dbl&gt;     &lt;dbl&gt;\n#&gt; 1     1   18.2      17.2\n\nnew.df = cbind(df1, df2)  # combine df1 and df2\n\nhead(new.df)              # see that df1 and df2 have combined\n\n#&gt;   id voc gini id export socialexp\n#&gt; 1  1   0 33.1  1 18.224    17.197\n#&gt; 2  2   0 33.1  2 19.854    16.660\n#&gt; 3  3   0 33.1  3 20.184    15.699\n#&gt; 4  4   0 33.1  4 20.149    15.858\n#&gt; 5  5   0 35.4  5 23.011    17.050\n#&gt; 6  6   0 35.4  6 19.795    16.853\n\n\nThe joining will be based on the shared variable between the two dataframes. This is usually an observation id.\nTo merge two dataframes with the same variables but different observations (essentially joining more observations together), we can use the full_join() function:\n\n# df1 has australia obs, df2 has belgium obs\nnew.df = full_join(df1, df2)\n\nThe joining will be done by the shared variables (columns).",
    "crumbs": [
      "data wrangling"
    ]
  },
  {
    "objectID": "cleaning.html",
    "href": "cleaning.html",
    "title": "data cleaning",
    "section": "",
    "text": "missing values, variable types\n\nThis page covers how to manipulate data. Use the sidebar to navigate between different sections. The packages required are:\n\nRPythonJulia\n\n\nFor the R code on this page, we will need the dplyr package.\n\n# packages needed:\nlibrary(dplyr)\n\ndplyr is part of the tidyverse package, so you can choose to load tidyverse instead.\n\n\n\n\n\n\n\n\n\n\n\nmissing values\nMissing values are often present in data. These can cause issues with estimation and models, so we need some way of identifying and getting rid of them.\n\nRPythonJulia\n\n\nMissing values are coded as NA or NaN in dataframes.\nTo detect missing values, we can use the is.na() function. This function detects if there is a missing value in each position of a dataframe or vector, and outputs a TRUE or FALSE, with TRUE indicating a missing value.\n\nis.na(df$voc) |&gt; head()  # head() to avoid long output, you do not need head()\n\n#&gt; [1] FALSE FALSE FALSE FALSE FALSE FALSE\n\n\nWe can replace any NAs with an if-else statement. For example, we might want to replace any NA in variable voc with the value 0:\n\ndf$voc &lt;- ifelse(\n  test  = is.na(df$voc) == TRUE,  # check if obs is a NA\n  yes   = 0,                      # if it is NA, replace with 0\n  no    = df$voc                  # if not NA, keep original voc value\n)\n\nWe can also omit any observations with NA values from the dataframe or vector of interest with the na.omit() function:\n\ndf = na.omit(df)  # omit any observation with NA value\n\n\n\n\n\n\n\n\n\n\n\n\n\nvariable types\nIt is important to ensure our variables are of the correct type, to ensure our analysis works as intended.\n\nRPythonJulia\n\n\nR variables can be of many different “types”, which operate differently in analysis.\nNumeric variables are any number, including decimals and negatives. We can coerce any variable into a numeric type with the as.numeric() function:\n\n# convert variable voc into numeric type\ndf$voc = as.numeric(df$voc)\n\nInteger variables are variables that only take values of integers, i.e. whole numbers. We can coerce any variable into an integer type with the as.integer() function:\n\n# convert variable voc into integer type\ndf$voc = as.integer(df$voc)\n\nFactor variables are variables that will be treated as categorical/binary variables in statistical analysis (ex. male/female, yes/no, country). We can coerce any variable into a factor type with the as.factor() function:\n\n# convert variable voc into factor type\ndf$voc = as.factor(df$voc)\n\nCharacter strings are variables that contain letters and symbols. We rarely wish to change other types into characters, but it is possible to coerce any variable into a character type with the as.character() function:\n\n# convert variable voc into factor type\ndf$voc = as.character(df$voc)",
    "crumbs": [
      "data cleaning"
    ]
  },
  {
    "objectID": "stats.html",
    "href": "stats.html",
    "title": "summary stats",
    "section": "",
    "text": "stats by variable\n\n\nsummary stats table\n\n\nstats by group",
    "crumbs": [
      "summary stats"
    ]
  },
  {
    "objectID": "plot.html",
    "href": "plot.html",
    "title": "plotting",
    "section": "",
    "text": "distributions\n\n\nscatterplots\n\n\ntheming",
    "crumbs": [
      "plotting"
    ]
  }
]